#!/usr/bin/env python3

import os
# directly terminate on broken pipe without throwing exception
import signal
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

import sys  # noqa

sys.path.append(os.getcwd())  # convenience: load implementations from cwd

import argparse  # noqa
import yaml  # noqa
from socket import gethostname  #noqa

from edflow.main import train, test  # noqa
from edflow.custom_logging import init_project, use_project, get_logger  # noqa
from edflow.custom_logging import set_global_stdout_level  # noqa
from edflow.hooks.checkpoint_hooks.common import get_latest_checkpoint  # noqa
from edflow.config import parse_unknown_args, update_config


def load_config(base_configs, additional_kwargs):
    config = dict()
    if base_configs:
        for base in base_configs:
            with open(base) as f:
                config.update(yaml.full_load(f))
    update_config(config, additional_kwargs)
    return config


def main(opt, additional_kwargs):
    config = load_config(opt.base, additional_kwargs)
    if not "model" in config:
        config["model"] = "edflow.util.NoModel"

    # Project manager: use existing project or set up new project
    if opt.project is not None:
        P = use_project(opt.project, postfix=opt.name)
    else:
        # Determine code root: If not specified, determine based on import path
        # of iterator
        if "code_root" in config:
            code_root = config["code_root"]
        else:
            impl = config.get("iterator", "")
            path = impl.split(".")
            # if it looks like a package path, take its root as the code dir
            # otherwise take cwd
            if len(path) > 0:
                code_root = path[0]
            else:
                code_root = "."

        # command line takes precedence over "experiment_name" from
        # config
        name = config.get("experiment_name", None)
        if opt.name is not None:
            name = opt.name
        P = init_project("logs", code_root=code_root, postfix=name)

    # Logger
    set_global_stdout_level(opt.log_level)
    logger = get_logger("main")
    logger.info(" ".join(sys.argv))
    logger.info("root: {}".format(P.root))
    if hasattr(P, "git_tag"):
        logger.info("git_tag: {}".format(P.git_tag))
    logger.info("hostname: {}".format(gethostname()))
    logger.info(opt)
    logger.info(P)

    if opt.train:
        if opt.checkpoint is not None:
            checkpoint = opt.checkpoint
        elif opt.project is not None:
            checkpoint = get_latest_checkpoint(P.checkpoints)
        else:
            checkpoint = None

        logger.info("Training config:\n{}".format(yaml.dump(config)))
        train(config, P.train, checkpoint, opt.retrain)
    else:
        disable_eval_all = disable_eval_forever = False
        if opt.checkpoint is not None:
            checkpoint = opt.checkpoint
            disable_eval_all = disable_eval_forever = True
        elif opt.project is not None:
            if any([config.get("eval_all", False), config.get("eval_forever", False)]):
                checkpoint = None
            else:
                checkpoint = get_latest_checkpoint(P.checkpoints)
                disable_eval_all = disable_eval_forever = True
        else:
            checkpoint = None

        if disable_eval_all:
            config.update({"eval_all": False})
            logger.info(
                "{} was disabled because you specified a checkpoint.".format("eval_all")
            )

        if disable_eval_forever:
            config.update({"eval_forever": False})
            logger.info(
                "{} was disabled because you specified a checkpoint.".format(
                    "eval_forever"
                )
            )

        logger.info(
            "Evaluation config:\n{}".format(yaml.dump(config))
        )
        bar_position = 0
        test(config, P.latest_eval, checkpoint, opt.nogpu, bar_position)


if __name__ == "__main__":
    default_log_dir = os.path.join(os.getcwd(), "log")

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-n", "--name", metavar="description", help="postfix of log directory."
    )
    parser.add_argument(
        "-b",
        "--base",
        nargs="*",
        metavar="base_config.yaml",
        help="Path to base config. Any parameter in here is overwritten by "
        "the train of eval config. Useful e.g. for model parameters, which"
        " stay constant between trainings and evaluations.",
        default=None,
    )
    parser.add_argument(
        "-t", "--train", action="store_true", help="run in training mode"
    )
    parser.add_argument("-p", "--project", help="path to existing project")
    parser.add_argument("-c", "--checkpoint", help="path to existing checkpoint")
    parser.add_argument(
        "-r", "--retrain", action="store_true", help="reset global step"
    )
    parser.add_argument(
        "--nogpu", action="store_true", help="disable gpu for tensorflow"
    )
    parser.add_argument(
        "-log",
        "--log-level",
        metavar="LEVEL",
        type=str,
        choices=["warn", "info", "debug", "critical"],
        default="info",
        help="Set the std-out logging level.",
    )
    parser.add_argument("-d", "--debug", action="store_true", help="enable post-mortem debugging")

    opt, unknown = parser.parse_known_args()
    additional_kwargs = parse_unknown_args(unknown)

    if "option" in additional_kwargs or "o" in additional_kwargs:
        msg = "\n" * 2
        msg += "=" * 20
        msg += (
            "\n\033[93m\033[1m\033[4mThe --option Argument is deprecated!"
            + "\033[0m\n"
            + "You can now pass additional options via --key value "
            + "pairs. This example equivalent to the old --option `key: "
            + "value`.\n"
            + "Passing --option `sth` is still possible, but will result"
            + " in a config entry `config[option] = sth`.\n"
        )
        msg += "=" * 20
        msg += "\n" * 2
        print(msg)
    if not opt.debug:
        main(opt, additional_kwargs)
    else:
        try:
            import pudb as debugger
        except ImportError:
            import pdb as debugger
        try:
            main(opt, additional_kwargs)
        except Exception:
            debugger.post_mortem()
            raise
